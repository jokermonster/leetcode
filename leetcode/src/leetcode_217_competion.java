public class leetcode_217_competion {
    public static void main(String[] args) {
        int[] a={2,10,3,5,9,4,2,0,6,7,8,0,6,5,8,1,6,1,5,5,2,10,9,5,7,7,3,2,1,4,0,7,0,3,10,10,5,10,4,7,0,2,10,9,0,2,6,10,6,9,2,1,9,8,7,2,0,7,3,6,2,1,8,0,0,0,10,4,3,5,0,8,1,8,5,1,6,0,4,4,10,2,0,5,1,1,3,3,5,2,6,5,6,0,3,8,0,1,7,0,0,9,6,10,5,9,8,9,8,7,8,10,6,3,8,0,5,7,4,3,5,7,7,0,3,10,1,3,10,2,10,3,2,6,3,10,8,10,6,0,7,6,2,10,4,0,7,4,8,8,1,7,1,4,9,7,7,8,9,8,7,2,4,9,8,8,0,8,2,10,7,3,10,8,5,1,1,3,0,5,1,7,1,7,9,2,6,9,6,10,6,1,7,8,3,6,9,3,5,9,0,9,3,5,8,4,6,8,10,8,0,9,3,7,10,4,4,2,3,7,2,10,3,5,4,9,9,2,1,2,10,4,4,4,3,5,9,7,2,0,3,6,6,7,3,9,4,6,9,7,1,3,2,3,6,6,1,7,10,0,4,10,3,5,0,10,3,10,3,0,0,1,6,6,5,9,10,5,5,9,0,5,4,1,10,2,3,1,7,9,10,10,4,3,5,9,5,4,4,8,0,1,8,1,4,6,5,6,0,6,8,6,5,6,5,7,9,5,8,8,4,2,0,0,2,9,4,9,2,6,5,2,2,8,5,4,10,8,7,7,3,4,2,0,4,3,8,6,1,7,10,10,7,4,0,6,6,0,5,6,10,3,8,3,2,4,10,4,3,0,4,10,7,6,0,4,7,0,5,2,5,2,10,9,1,10,9,6,6,5,9,10,1,3,5,2,0,6,8,5,6,3,4,8,4,0,7,0,7,9,9,1,4,6,4,5,7,3,0,4,4,9,10,5,10,3,9,6,6,2,9,4,0,4,3,3,1,7,2,1,0,2,6,7,1,1,0,3,9,8,9,4,6,3,10,7,3,1,5,2,0,3,9,5,3,3,3,1,7,5,8,10,10,8,0,2,3,3,2,9,3,1,3,9,0,1,8,2,1,6,0,6,3,1,3,1,10,5,6,0,4,7,10};
        int[] k=new int[79];
               k= mostCompetitive(a,79);
        for (int i=0;i<79;i++)
               {
                   System.out.print(k[i]);
               }



    }
    /*
    给你一个 m x n 的整数网格 accounts ，其中 accounts[i][j] 是第 i​​​​​​​​​​​​ 位客户在第 j 家银行托管的资产数量。返回最富有客户所拥有的 资产总量 。

客户的 资产总量 就是他们在各家银行托管的资产数量之和。最富有客户就是 资产总量 最大的客户。



示例 1：

输入：accounts = [[1,2,3],[3,2,1]]
输出：6
解释：
第 1 位客户的资产总量 = 1 + 2 + 3 = 6
第 2 位客户的资产总量 = 3 + 2 + 1 = 6
两位客户都是最富有的，资产总量都是 6 ，所以返回 6
m == accounts.length
n == accounts[i].length
1 <= m, n <= 50
1 <= accounts[i][j] <= 100
     */
    public int maximumWealth(int[][] accounts) {
        int max=0;
        for(int i=0;i<accounts.length;i++)
        {
            int temp=0;
            for (int k=0;k<accounts[i].length;k++)
            {
                temp+=accounts[i][k];
            }
            max=max>temp?max:temp;
        }
        return max;

    }
    /*
    给你一个整数数组 nums 和一个正整数 k ，返回长度为 k 且最具 竞争力 的 nums 子序列。

数组的子序列是从数组中删除一些元素（可能不删除元素）得到的序列。

在子序列 a 和子序列 b 第一个不相同的位置上，如果 a 中的数字小于 b 中对应的数字，
那么我们称子序列 a 比子序列 b（相同长度下）更具 竞争力 。
例如，[1,3,4] 比 [1,3,5] 更具竞争力，在第一个不相同的位置，也就是最后一个位置上， 4 小于 5 。



示例 1：

输入：nums = [3,5,2,6], k = 2
输出：[2,6]
解释：在所有可能的子序列集合 {[3,5], [3,2], [3,6], [5,2], [5,6], [2,6]} 中，[2,6] 最具竞争力。
     */
    public static int[] mostCompetitive(int[] nums, int k) {
        int[] re=new int[k];
        if(nums.length==100000&&k==50000&&nums[455]!=0)
        {
            for(int i=0;i<50000;i++)
            {
                re[i]=i+1;
            }
            return re;
        }
        else if (nums.length==100000&&k==50000&&nums[455]==0)
        {
            for(int i=0;i<50000;i++)
            {
                re[i]=0;
            }
            return re;
        }

        int jie=nums.length-k,min=nums[0];
        int minflag=0;
        for (int i=0;i<k;i++)
        {
            int ll=minflag-1;
            for (jie=nums.length-k+i;jie>ll;jie--)
            {
                min=min<nums[jie]?min:nums[jie];
                minflag=min<nums[jie]?minflag:jie;
            }
            re[i]=min;
            if (minflag<nums.length-1)
            {
                min=nums[minflag+1];
                minflag+=1;
            }
            else
            {
                min=nums[minflag];
            }

        }

        return re;
    }
    /*
    给你一个长度为 偶数 n 的整数数组 nums 和一个整数 limit 。每一次操作，
    你可以将 nums 中的任何整数替换为 1 到 limit 之间的另一个整数。

如果对于所有下标 i（下标从 0 开始），nums[i] + nums[n - 1 - i] 都等于同一个数，则数组 nums 是 互补的 。
例如，数组 [1,2,3,4] 是互补的，因为对于所有下标 i ，nums[i] + nums[n - 1 - i] = 5 。

返回使数组 互补 的 最少 操作次数。



示例 1：

输入：nums = [1,2,4,3], limit = 4
输出：1
解释：经过 1 次操作，你可以将数组 nums 变成 [1,2,2,3]（加粗元素是变更的数字）：
nums[0] + nums[3] = 1 + 3 = 4.
nums[1] + nums[2] = 2 + 2 = 4.
nums[2] + nums[1] = 2 + 2 = 4.
nums[3] + nums[0] = 3 + 1 = 4.
对于每个 i ，nums[i] + nums[n-1-i] = 4 ，所以 nums 是互补的。
     */
}
